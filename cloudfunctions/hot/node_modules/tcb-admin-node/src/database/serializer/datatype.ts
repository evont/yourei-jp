// transpile internal data type
import { SYMBOL_GEO_POINT, SYMBOL_SERVER_DATE } from '../../../../api/database/helper/symbol'
import { getType, isObject, isArray, isDate, isNumber, isInternalObject } from 'utils/type'
import { Point } from '../../../../api/database/geo'
import { serverDate } from '../../../../api/database/date'
import { CloudSDKError } from 'utils/error'
import { ERR_CODE } from 'config/error.config'

// types
import { DB, AnyObject } from 'typings'

export function serialize(val: any): DB.IQueryCondition {
  return serializeHelper(val, [val])
}

function serializeHelper(
  val: any,
  visited: object[],
): Record<string, any> {
  if (isInternalObject(val)) {
    switch (val._internalType) {
      case SYMBOL_GEO_POINT: {
        return (val as DB.GeoPoint).toJSON()
      }
      case SYMBOL_SERVER_DATE: {
        return {
          $date: (val as DB.ServerDate).options,
        }
      }
      default: {
        return val.toJSON ? val.toJSON() : val
      }
    }
  } else if (isDate(val)) {
    return {
      $date: +val,
    }
  } else if (isArray(val)) {
    return val.map(item => {
      if (visited.indexOf(item) > -1) {
        throw new CloudSDKError({
          errCode: ERR_CODE.SDK_DATABASE_CIRCULAR_REFERENCE as number,
          errMsg: `Cannot convert circular structure to JSON`,
        })
      }

      return serializeHelper(item, [
        ...visited,
        item,
      ])
    })
  } else if (isObject(val)) {
    const ret: AnyObject = { ...val }
    for (const key in ret) {
      if (visited.indexOf(ret[key]) > -1) {
        throw new CloudSDKError({
          errCode: ERR_CODE.SDK_DATABASE_CIRCULAR_REFERENCE as number,
          errMsg: `Cannot convert circular structure to JSON`,
        })
      }

      ret[key] = serializeHelper(ret[key], [
        ...visited,
        ret[key],
      ])
    }
    return ret
  } else {
    return val
  }
}

export function deserialize(object: AnyObject): any {
  const ret = { ...object }
  for (const key in ret) {
    switch (key) {
      case '$date': {
        switch (getType(ret[key])) {
          case 'number': {
            // normal timestamp
            return new Date(ret[key])
          }
          case 'object': {
            // serverDate
            return serverDate(ret[key])
          }
        }
        break
      }
      case 'type': {
        switch (ret.type) {
          case 'Point': {
            // GeoPoint
            if (isArray(ret.coordinates) && isNumber(ret.coordinates[0]) && isNumber(ret.coordinates[1])) {
              return new Point(ret.coordinates[0], ret.coordinates[1])
            }
            break
          }
        }
        break
      }
    }
  }
  return object
}
